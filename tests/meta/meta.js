let fs = require('fs');

let start = Date.now();

// const defaultValueRegExp = new RegExp('default:\\s*(.*?)[\\s,}]');

let source = process.argv[2];
let destination = process.argv[3];

readFolders(source, (root, path, done) => {
    let errors = [];
    read(`${root}/${path}.ts`, source => {
        let meta = {
            x: path,
            attributes: {},
            mixins: []
        };

        createProps(meta, source, errors);
        createMixins(meta, source, errors);

        // console.log(path, meta.mixins);
        write(`${destination}/${path}/${path}.meta.json`, meta, _ => {
            done(errors);
        }, err => {
            errors.push(err.message);
            done(errors);
        });
    }, err => {
        errors.push(err.message);
        done(errors);

    });
});

// function validateMeta(meta, errors) {
//     // from ComponentMeta interface
//     let supportedKeys = {
//         // tag: null,
//         // folder: null,
//         attributes: null,
//         mixins: null,
//         // production: null,
//         methods: null,
//         // category: null,
//         // preview: null
//         /* Autogenerated properties that should not appear in the meta
//         name
//         overview */
//     };

//     let keys = Object.keys(meta).filter(k => meta.hasOwnProperty(k) && supportedKeys[k] === undefined);

//     keys.forEach(k => errors.push(`Unknown component property ${k}`));
// }

function createProps(meta, source, errors) {
    let prop = undefined;
    const propRegExp = new RegExp(`@Prop\\(([\\s\\S]*?)\\)\\s*(?:@Model\\(\\'?[\\w\\d]+\\'?\\)\\s*)?public\\s*(\\w*):\\s*(\\w\\s|.*);`, 'g');
    do {
        prop = propRegExp.exec(source);
        if (prop) {
            let propName = prop[2];
            let propType = prop[3];
            meta.attributes[propName] = {
                type: propType
            }
            // if (meta.attributes && meta.attributes[prop[2]] !== undefined) {
            //     let attributeMeta = meta.attributes[prop[2]];
            //     if (attributeMeta.type !== prop[3]) {
            //         errors.push(`Property ${prop[2]} should be of type ${prop[3]}, not ${attributeMeta.type}`);
            //     }
            //     if (prop[1]) {
            //         let defaultValueMatch = defaultValueRegExp.exec(prop[1]);
            //         let defaultValue = defaultValueMatch ? defaultValueMatch[1] : undefined;
            //         if (defaultValue && defaultValue[0] === '\'' && defaultValue[defaultValue.length - 1] === '\'') {
            //             defaultValue = defaultValue.slice(1, -1);
            //         }
            //         if (defaultValue !== 'function()' && String(attributeMeta.default) !== String(defaultValue)) {
            //             errors.push(`Property ${prop[2]} default value should be ${defaultValue}, not ${attributeMeta.default}`);
            //         }
            //     }
            //     delete meta.attributes[prop[2]];
            // } else {
            //     errors.push(`Property ${prop[2]} not found in meta`);
            // }
        }
    } while (prop);

    // if (meta.attributes) {
    //     Object.keys(meta.attributes).forEach(attribute => {
    //         errors.push(`Property ${attribute} is not used by the component`);
    //     });
    // }
}

// function validateProps(meta, source, errors) {
//     let prop = undefined;
//     do {
//         prop = propRegExp.exec(source);
//         if (prop) {
//             if (meta.attributes && meta.attributes[prop[2]] !== undefined) {
//                 let attributeMeta = meta.attributes[prop[2]];
//                 if (attributeMeta.type !== prop[3]) {
//                     errors.push(`Property ${prop[2]} should be of type ${prop[3]}, not ${attributeMeta.type}`);
//                 }
//                 if (prop[1]) {
//                     let defaultValueMatch = defaultValueRegExp.exec(prop[1]);
//                     let defaultValue = defaultValueMatch ? defaultValueMatch[1] : undefined;
//                     if (defaultValue && defaultValue[0] === '\'' && defaultValue[defaultValue.length - 1] === '\'') {
//                         defaultValue = defaultValue.slice(1, -1);
//                     }
//                     if (defaultValue !== 'function()' && String(attributeMeta.default) !== String(defaultValue)) {
//                         errors.push(`Property ${prop[2]} default value should be ${defaultValue}, not ${attributeMeta.default}`);
//                     }
//                 }
//                 delete meta.attributes[prop[2]];
//             } else {
//                 errors.push(`Property ${prop[2]} not found in meta`);
//             }
//         }
//     } while (prop);

//     if (meta.attributes) {
//         Object.keys(meta.attributes).forEach(attribute => {
//             errors.push(`Property ${attribute} is not used by the component`);
//         });
//     }
// }

function createMixins(meta, source, errors) {
    // meta.mixinsObj = {}; // used as map for validation
    // if (meta.mixins) {
    //     meta.mixins.forEach(mixin => meta.mixinsObj[mixin] = true);
    // }

    const mixinsRegExp = new RegExp('mixins:\\s*\\[([\\s\\S]*?)\\]');
    let match = mixinsRegExp.exec(source);
    if (match) {
        let mixinMatch = undefined;
        const mixinNameRegExp = new RegExp('([\\w\\d]+)', 'g');
        do {
            mixinMatch = mixinNameRegExp.exec(match[1]);
            if (mixinMatch) {
                let mixin = mixinMatch[1];
                meta.mixins.push(mixin);
            }
        }
        while (mixinMatch);
    }

    // Object.keys(meta.mixinsObj).forEach(mixin => {
    //     errors.push(`Mixin ${mixin} is not used by the component`);
    // });
}


// function validateMixins(meta, source, errors) {
//     meta.mixinsObj = {}; // used as map for validation
//     if (meta.mixins) {
//         meta.mixins.forEach(mixin => meta.mixinsObj[mixin] = true);
//     }

//     let match = mixinsRegExp.exec(source);
//     if (match) {
//         let mixinMatch = undefined;
//         do {
//             mixinMatch = mixinNameRegExp.exec(match[1]);
//             if (mixinMatch) {
//                 let mixin = mixinMatch[1];
//                 // console.log(mixin);
//                 // console.log(meta.mixinsObj);
//                 if (meta.mixinsObj[mixin] === undefined) {
//                     errors.push(`Mixin ${mixin} not found in meta`);
//                 } else {
//                     delete meta.mixinsObj[mixin];
//                 }
//             }
//         }
//         while (mixinMatch);
//     }

//     Object.keys(meta.mixinsObj).forEach(mixin => {
//         errors.push(`Mixin ${mixin} is not used by the component`);
//     });
// }

function readFolders(folder, cb) {
    let exitCode = 0;
    let toComplete = {};
    let failed = 0;
    let total = 0;

    fs.readdir(folder, (err, files) => {
        if (err) {
            throw err;
        }
        files.forEach(file => {
            let fullpath = folder + '/' + file;
            if (fs.statSync(fullpath).isDirectory()) {
                toComplete[file] = false;
                total++;

                let done = errors => {
                    if (errors.length === 0) {
                        logSuccess(file);
                    } else {
                        exitCode = 1;
                        failed++;
                        logError(file);
                        errors.forEach(error => logErrorIndent(error));
                    }
                    console.log();
                    delete toComplete[file];
                    if (Object.keys(toComplete).length === 0) {
                        let end = Date.now();

                        console.log(`Processed ${total} files in ${(end - start) / 1000} secs`);
                        let status = `TOTAL: ${failed} FAILED, ${total - failed} SUCCESS`;
                        internalLog(false, failed === 0 ? 32 : 31, status);

                        console.log();
                        process.exit(exitCode);
                    }
                };
                cb(fullpath, file, done);
            }
        });
    });
};

function read(file, cb, cbError) {
    fs.readFile(file, 'utf8', (err, data) => {
        if (err) {
            cbError(err);
        } else {
            cb(data);
        }
    });
}

function write(file, meta, cb, cbError) {
    // console.log(file, meta.mixins);
    fs.writeFile(file, JSON.stringify(meta), 'utf8', (err) => {
        if (err) {
            cbError(err);
        } else {
            cb();
        }
    });
}

function internalLog(indent, colorCode, char, ...params) {
    let c = indent ? '    ' + char : char;
    console.log(`\x1b[${colorCode}m%s\x1b[0m`, c, ...params);
}

function logSuccess(...params) {
    internalLog(false, 32, 'âœ“', ...params);
}

function logError(...params) {
    internalLog(false, 31, 'x', ...params);
}

function logErrorIndent(...params) {
    internalLog(true, 31, 'x', ...params);
}
